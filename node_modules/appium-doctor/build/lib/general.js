"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.OptionalMjpegConsumerCommandCheck = exports.OptionalFfmpegCommandCheck = exports.OptionalOpencv4nodejsCommandCheck = exports.OptionalPythonVersionCheck = exports.NodeVersionCheck = exports.NodeBinaryCheck = void 0;

require("source-map-support/register");

var _utils = require("./utils");

var _teen_process = require("teen_process");

var _doctor = require("./doctor");

var _nodeDetector = _interopRequireDefault(require("./node-detector"));

var _os = require("os");

var _appiumSupport = require("appium-support");

let checks = [];

class NodeBinaryCheck extends _doctor.DoctorCheck {
  async diagnose() {
    let nodePath = await _nodeDetector.default.detect();
    return nodePath ? (0, _utils.ok)(`The Node.js binary was found at: ${nodePath}`) : (0, _utils.nok)('The Node.js binary was NOT found!');
  }

  fix() {
    return `Manually setup Node.js.`;
  }

}

exports.NodeBinaryCheck = NodeBinaryCheck;
checks.push(new NodeBinaryCheck());

class NodeVersionCheck extends _doctor.DoctorCheck {
  async diagnose() {
    let nodePath = await _nodeDetector.default.detect();

    if (!nodePath) {
      return (0, _utils.nok)('Node is not installed, so no version to check!');
    }

    let {
      stdout
    } = await (0, _teen_process.exec)(nodePath, ['--version']);
    let versionString = stdout.replace('v', '').trim();
    let version = parseInt(versionString, 10);

    if (Number.isNaN(version)) {
      return (0, _utils.nok)(`Unable to find node version (version = '${versionString}')`);
    }

    return version >= 4 ? (0, _utils.ok)(`Node version is ${versionString}`) : (0, _utils.nok)('Node version should be at least 4!');
  }

  fix() {
    return `Manually upgrade Node.js.`;
  }

}

exports.NodeVersionCheck = NodeVersionCheck;
checks.push(new NodeVersionCheck());

class OptionalPythonVersionCheck extends _doctor.DoctorCheck {
  async diagnose() {
    const pythonPath = await (0, _utils.resolveExecutablePath)(`python${_appiumSupport.system.isWindows() ? `.EXE` : ''}`);

    if (!pythonPath) {
      return (0, _utils.nokOptional)(`Python required by node-gyp (used by heapdump) not found in PATH: ${process.env.PATH}`);
    }

    const {
      stdout,
      stderr
    } = await (0, _teen_process.exec)(pythonPath, ['-V']);
    let versionString = `${stdout} ${stderr}`.match(/Python (\d(\.\d+)*)/g);

    if (versionString) {
      versionString = versionString.pop().replace('Python ', '');
    }

    const version = parseInt(versionString, 10);

    if (Number.isNaN(version)) {
      return (0, _utils.nokOptional)(`Unable to identify Python version correctly (version = '${versionString}') at ${pythonPath}. Please make sure your Python environment in PATH: ${process.env.PATH}. node-gyp (used by heapdump) requires Python 2.x`);
    }

    return version === 2 ? (0, _utils.okOptional)(`Python required by node-gyp (used by heapdump) is installed at: ${pythonPath}. Installed version is: ${versionString}`) : (0, _utils.nokOptional)('Python version required by node-gyp (used by heapdump) should be 2.x');
  }

  fix() {
    return `Manually configure Python 2.x environment. node-gyp which is NodeJS toolchain requires Python 2.x`;
  }

}

exports.OptionalPythonVersionCheck = OptionalPythonVersionCheck;
checks.push(new OptionalPythonVersionCheck());

class OptionalOpencv4nodejsCommandCheck extends _doctor.DoctorCheck {
  async diagnose() {
    const packageName = 'opencv4nodejs';
    const packageInfo = await (0, _utils.getNpmPackageInfo)(packageName);

    if (packageInfo) {
      return (0, _utils.okOptional)(`${packageName} is installed at: ${packageInfo.path}. Installed version is: ${packageInfo.version}`);
    }

    return (0, _utils.nokOptional)(`${packageName} cannot be found.`);
  }

  async fix() {
    return 'Why opencv4nodejs is needed and how to install it: https://github.com/appium/appium/blob/master/docs/en/writing-running-appium/image-comparison.md';
  }

}

exports.OptionalOpencv4nodejsCommandCheck = OptionalOpencv4nodejsCommandCheck;
checks.push(new OptionalOpencv4nodejsCommandCheck());

class OptionalFfmpegCommandCheck extends _doctor.DoctorCheck {
  async diagnose() {
    const ffmpegPath = await (0, _utils.resolveExecutablePath)('ffmpeg');
    return ffmpegPath ? (0, _utils.okOptional)(`ffmpeg is installed at: ${ffmpegPath}. ${(await (0, _teen_process.exec)('ffmpeg', ['-version'])).stdout.split(_os.EOL)[0]}`) : (0, _utils.nokOptional)('ffmpeg cannot be found');
  }

  async fix() {
    return 'ffmpeg is needed to record screen features. Please read https://www.ffmpeg.org/ to install it';
  }

}

exports.OptionalFfmpegCommandCheck = OptionalFfmpegCommandCheck;
checks.push(new OptionalFfmpegCommandCheck());

class OptionalMjpegConsumerCommandCheck extends _doctor.DoctorCheck {
  async diagnose() {
    const packageName = 'mjpeg-consumer';
    const packageInfo = await (0, _utils.getNpmPackageInfo)(packageName);

    if (packageInfo) {
      return (0, _utils.okOptional)(`${packageName} is installed at: ${packageInfo.path}. Installed version is: ${packageInfo.version}`);
    }

    return (0, _utils.nokOptional)(`${packageName} cannot be found.`);
  }

  async fix() {
    return 'mjpeg-consumer module is required to use MJPEG-over-HTTP features. Please install it with `npm i -g mjpeg-consumer`.';
  }

}

exports.OptionalMjpegConsumerCommandCheck = OptionalMjpegConsumerCommandCheck;
checks.push(new OptionalMjpegConsumerCommandCheck());
var _default = checks;
exports.default = _default;require('source-map-support').install();


//# sourceMappingURL=data:application/json;charset=utf8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImxpYi9nZW5lcmFsLmpzIl0sIm5hbWVzIjpbImNoZWNrcyIsIk5vZGVCaW5hcnlDaGVjayIsIkRvY3RvckNoZWNrIiwiZGlhZ25vc2UiLCJub2RlUGF0aCIsIk5vZGVEZXRlY3RvciIsImRldGVjdCIsImZpeCIsInB1c2giLCJOb2RlVmVyc2lvbkNoZWNrIiwic3Rkb3V0IiwidmVyc2lvblN0cmluZyIsInJlcGxhY2UiLCJ0cmltIiwidmVyc2lvbiIsInBhcnNlSW50IiwiTnVtYmVyIiwiaXNOYU4iLCJPcHRpb25hbFB5dGhvblZlcnNpb25DaGVjayIsInB5dGhvblBhdGgiLCJzeXN0ZW0iLCJpc1dpbmRvd3MiLCJwcm9jZXNzIiwiZW52IiwiUEFUSCIsInN0ZGVyciIsIm1hdGNoIiwicG9wIiwiT3B0aW9uYWxPcGVuY3Y0bm9kZWpzQ29tbWFuZENoZWNrIiwicGFja2FnZU5hbWUiLCJwYWNrYWdlSW5mbyIsInBhdGgiLCJPcHRpb25hbEZmbXBlZ0NvbW1hbmRDaGVjayIsImZmbXBlZ1BhdGgiLCJzcGxpdCIsIkVPTCIsIk9wdGlvbmFsTWpwZWdDb25zdW1lckNvbW1hbmRDaGVjayJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQSxJQUFJQSxNQUFNLEdBQUcsRUFBYjs7QUFHQSxNQUFNQyxlQUFOLFNBQThCQyxtQkFBOUIsQ0FBMEM7QUFDeEMsUUFBTUMsUUFBTixHQUFrQjtBQUNoQixRQUFJQyxRQUFRLEdBQUcsTUFBTUMsc0JBQWFDLE1BQWIsRUFBckI7QUFDQSxXQUFPRixRQUFRLEdBQUcsZUFBSSxvQ0FBbUNBLFFBQVMsRUFBaEQsQ0FBSCxHQUNiLGdCQUFJLG1DQUFKLENBREY7QUFFRDs7QUFFREcsRUFBQUEsR0FBRyxHQUFJO0FBQ0wsV0FBUSx5QkFBUjtBQUNEOztBQVR1Qzs7O0FBVzFDUCxNQUFNLENBQUNRLElBQVAsQ0FBWSxJQUFJUCxlQUFKLEVBQVo7O0FBR0EsTUFBTVEsZ0JBQU4sU0FBK0JQLG1CQUEvQixDQUEyQztBQUN6QyxRQUFNQyxRQUFOLEdBQWtCO0FBQ2hCLFFBQUlDLFFBQVEsR0FBRyxNQUFNQyxzQkFBYUMsTUFBYixFQUFyQjs7QUFDQSxRQUFJLENBQUNGLFFBQUwsRUFBZTtBQUNiLGFBQU8sZ0JBQUksZ0RBQUosQ0FBUDtBQUNEOztBQUNELFFBQUk7QUFBQ00sTUFBQUE7QUFBRCxRQUFXLE1BQU0sd0JBQUtOLFFBQUwsRUFBZSxDQUFDLFdBQUQsQ0FBZixDQUFyQjtBQUNBLFFBQUlPLGFBQWEsR0FBR0QsTUFBTSxDQUFDRSxPQUFQLENBQWUsR0FBZixFQUFvQixFQUFwQixFQUF3QkMsSUFBeEIsRUFBcEI7QUFDQSxRQUFJQyxPQUFPLEdBQUdDLFFBQVEsQ0FBQ0osYUFBRCxFQUFnQixFQUFoQixDQUF0Qjs7QUFDQSxRQUFJSyxNQUFNLENBQUNDLEtBQVAsQ0FBYUgsT0FBYixDQUFKLEVBQTJCO0FBQ3pCLGFBQU8sZ0JBQUssMkNBQTBDSCxhQUFjLElBQTdELENBQVA7QUFDRDs7QUFDRCxXQUFPRyxPQUFPLElBQUksQ0FBWCxHQUFlLGVBQUksbUJBQWtCSCxhQUFjLEVBQXBDLENBQWYsR0FDTCxnQkFBSSxvQ0FBSixDQURGO0FBRUQ7O0FBRURKLEVBQUFBLEdBQUcsR0FBSTtBQUNMLFdBQVEsMkJBQVI7QUFDRDs7QUFsQndDOzs7QUFvQjNDUCxNQUFNLENBQUNRLElBQVAsQ0FBWSxJQUFJQyxnQkFBSixFQUFaOztBQUdBLE1BQU1TLDBCQUFOLFNBQXlDaEIsbUJBQXpDLENBQXFEO0FBQ25ELFFBQU1DLFFBQU4sR0FBa0I7QUFDaEIsVUFBTWdCLFVBQVUsR0FBRyxNQUFNLGtDQUF1QixTQUFRQyxzQkFBT0MsU0FBUCxLQUFzQixNQUF0QixHQUE4QixFQUFHLEVBQWhFLENBQXpCOztBQUNBLFFBQUksQ0FBQ0YsVUFBTCxFQUFpQjtBQUNmLGFBQU8sd0JBQWEscUVBQW9FRyxPQUFPLENBQUNDLEdBQVIsQ0FBWUMsSUFBSyxFQUFsRyxDQUFQO0FBQ0Q7O0FBR0QsVUFBTTtBQUFDZCxNQUFBQSxNQUFEO0FBQVNlLE1BQUFBO0FBQVQsUUFBbUIsTUFBTSx3QkFBS04sVUFBTCxFQUFpQixDQUFDLElBQUQsQ0FBakIsQ0FBL0I7QUFDQSxRQUFJUixhQUFhLEdBQUksR0FBRUQsTUFBTyxJQUFHZSxNQUFPLEVBQXBCLENBQXNCQyxLQUF0QixDQUE0QixzQkFBNUIsQ0FBcEI7O0FBQ0EsUUFBSWYsYUFBSixFQUFtQjtBQUNqQkEsTUFBQUEsYUFBYSxHQUFHQSxhQUFhLENBQUNnQixHQUFkLEdBQW9CZixPQUFwQixDQUE0QixTQUE1QixFQUF1QyxFQUF2QyxDQUFoQjtBQUNEOztBQUNELFVBQU1FLE9BQU8sR0FBR0MsUUFBUSxDQUFDSixhQUFELEVBQWdCLEVBQWhCLENBQXhCOztBQUNBLFFBQUlLLE1BQU0sQ0FBQ0MsS0FBUCxDQUFhSCxPQUFiLENBQUosRUFBMkI7QUFDekIsYUFBTyx3QkFBYSwyREFBMERILGFBQWMsU0FBUVEsVUFBVyx1REFBc0RHLE9BQU8sQ0FBQ0MsR0FBUixDQUFZQyxJQUFLLG1EQUEvSyxDQUFQO0FBQ0Q7O0FBQ0QsV0FBT1YsT0FBTyxLQUFLLENBQVosR0FBZ0IsdUJBQVksbUVBQWtFSyxVQUFXLDJCQUEwQlIsYUFBYyxFQUFqSSxDQUFoQixHQUNMLHdCQUFZLHNFQUFaLENBREY7QUFFRDs7QUFFREosRUFBQUEsR0FBRyxHQUFJO0FBQ0wsV0FBUSxtR0FBUjtBQUNEOztBQXZCa0Q7OztBQXlCckRQLE1BQU0sQ0FBQ1EsSUFBUCxDQUFZLElBQUlVLDBCQUFKLEVBQVo7O0FBR0EsTUFBTVUsaUNBQU4sU0FBZ0QxQixtQkFBaEQsQ0FBNEQ7QUFDMUQsUUFBTUMsUUFBTixHQUFrQjtBQUNoQixVQUFNMEIsV0FBVyxHQUFHLGVBQXBCO0FBQ0EsVUFBTUMsV0FBVyxHQUFHLE1BQU0sOEJBQWtCRCxXQUFsQixDQUExQjs7QUFFQSxRQUFJQyxXQUFKLEVBQWlCO0FBQ2YsYUFBTyx1QkFBWSxHQUFFRCxXQUFZLHFCQUFvQkMsV0FBVyxDQUFDQyxJQUFLLDJCQUEwQkQsV0FBVyxDQUFDaEIsT0FBUSxFQUE3RyxDQUFQO0FBQ0Q7O0FBQ0QsV0FBTyx3QkFBYSxHQUFFZSxXQUFZLG1CQUEzQixDQUFQO0FBQ0Q7O0FBRUQsUUFBTXRCLEdBQU4sR0FBYTtBQUNYLFdBQU8sb0pBQVA7QUFDRDs7QUFieUQ7OztBQWU1RFAsTUFBTSxDQUFDUSxJQUFQLENBQVksSUFBSW9CLGlDQUFKLEVBQVo7O0FBRUEsTUFBTUksMEJBQU4sU0FBeUM5QixtQkFBekMsQ0FBcUQ7QUFDbkQsUUFBTUMsUUFBTixHQUFrQjtBQUNoQixVQUFNOEIsVUFBVSxHQUFHLE1BQU0sa0NBQXNCLFFBQXRCLENBQXpCO0FBQ0EsV0FBT0EsVUFBVSxHQUNiLHVCQUFZLDJCQUEwQkEsVUFBVyxLQUFJLENBQUMsTUFBTSx3QkFBSyxRQUFMLEVBQWUsQ0FBQyxVQUFELENBQWYsQ0FBUCxFQUFxQ3ZCLE1BQXJDLENBQTRDd0IsS0FBNUMsQ0FBa0RDLE9BQWxELEVBQXVELENBQXZELENBQTBELEVBQS9HLENBRGEsR0FFYix3QkFBWSx3QkFBWixDQUZKO0FBR0Q7O0FBRUQsUUFBTTVCLEdBQU4sR0FBYTtBQUNYLFdBQU8sK0ZBQVA7QUFDRDs7QUFWa0Q7OztBQVlyRFAsTUFBTSxDQUFDUSxJQUFQLENBQVksSUFBSXdCLDBCQUFKLEVBQVo7O0FBR0EsTUFBTUksaUNBQU4sU0FBZ0RsQyxtQkFBaEQsQ0FBNEQ7QUFDMUQsUUFBTUMsUUFBTixHQUFrQjtBQUNoQixVQUFNMEIsV0FBVyxHQUFHLGdCQUFwQjtBQUNBLFVBQU1DLFdBQVcsR0FBRyxNQUFNLDhCQUFrQkQsV0FBbEIsQ0FBMUI7O0FBRUEsUUFBSUMsV0FBSixFQUFpQjtBQUNmLGFBQU8sdUJBQVksR0FBRUQsV0FBWSxxQkFBb0JDLFdBQVcsQ0FBQ0MsSUFBSywyQkFBMEJELFdBQVcsQ0FBQ2hCLE9BQVEsRUFBN0csQ0FBUDtBQUNEOztBQUNELFdBQU8sd0JBQWEsR0FBRWUsV0FBWSxtQkFBM0IsQ0FBUDtBQUNEOztBQUVELFFBQU10QixHQUFOLEdBQWE7QUFDWCxXQUFPLHNIQUFQO0FBQ0Q7O0FBYnlEOzs7QUFlNURQLE1BQU0sQ0FBQ1EsSUFBUCxDQUFZLElBQUk0QixpQ0FBSixFQUFaO2VBS2VwQyxNIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgb2ssIG5vaywgb2tPcHRpb25hbCwgbm9rT3B0aW9uYWwsIHJlc29sdmVFeGVjdXRhYmxlUGF0aCwgZ2V0TnBtUGFja2FnZUluZm8gfSBmcm9tICcuL3V0aWxzJztcbmltcG9ydCB7IGV4ZWMgfSBmcm9tICd0ZWVuX3Byb2Nlc3MnO1xuaW1wb3J0IHsgRG9jdG9yQ2hlY2sgfSBmcm9tICcuL2RvY3Rvcic7XG5pbXBvcnQgTm9kZURldGVjdG9yIGZyb20gJy4vbm9kZS1kZXRlY3Rvcic7XG5pbXBvcnQgeyBFT0wgfSBmcm9tICdvcyc7XG5pbXBvcnQgeyBzeXN0ZW0gfSBmcm9tICdhcHBpdW0tc3VwcG9ydCc7XG5cbmxldCBjaGVja3MgPSBbXTtcblxuLy8gTm9kZSBCaW5hcnlcbmNsYXNzIE5vZGVCaW5hcnlDaGVjayBleHRlbmRzIERvY3RvckNoZWNrIHtcbiAgYXN5bmMgZGlhZ25vc2UgKCkge1xuICAgIGxldCBub2RlUGF0aCA9IGF3YWl0IE5vZGVEZXRlY3Rvci5kZXRlY3QoKTtcbiAgICByZXR1cm4gbm9kZVBhdGggPyBvayhgVGhlIE5vZGUuanMgYmluYXJ5IHdhcyBmb3VuZCBhdDogJHtub2RlUGF0aH1gKSA6XG4gICAgICBub2soJ1RoZSBOb2RlLmpzIGJpbmFyeSB3YXMgTk9UIGZvdW5kIScpO1xuICB9XG5cbiAgZml4ICgpIHtcbiAgICByZXR1cm4gYE1hbnVhbGx5IHNldHVwIE5vZGUuanMuYDtcbiAgfVxufVxuY2hlY2tzLnB1c2gobmV3IE5vZGVCaW5hcnlDaGVjaygpKTtcblxuLy8gTm9kZSB2ZXJzaW9uXG5jbGFzcyBOb2RlVmVyc2lvbkNoZWNrIGV4dGVuZHMgRG9jdG9yQ2hlY2sge1xuICBhc3luYyBkaWFnbm9zZSAoKSB7XG4gICAgbGV0IG5vZGVQYXRoID0gYXdhaXQgTm9kZURldGVjdG9yLmRldGVjdCgpO1xuICAgIGlmICghbm9kZVBhdGgpIHtcbiAgICAgIHJldHVybiBub2soJ05vZGUgaXMgbm90IGluc3RhbGxlZCwgc28gbm8gdmVyc2lvbiB0byBjaGVjayEnKTtcbiAgICB9XG4gICAgbGV0IHtzdGRvdXR9ID0gYXdhaXQgZXhlYyhub2RlUGF0aCwgWyctLXZlcnNpb24nXSk7XG4gICAgbGV0IHZlcnNpb25TdHJpbmcgPSBzdGRvdXQucmVwbGFjZSgndicsICcnKS50cmltKCk7XG4gICAgbGV0IHZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uU3RyaW5nLCAxMCk7XG4gICAgaWYgKE51bWJlci5pc05hTih2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIG5vayhgVW5hYmxlIHRvIGZpbmQgbm9kZSB2ZXJzaW9uICh2ZXJzaW9uID0gJyR7dmVyc2lvblN0cmluZ30nKWApO1xuICAgIH1cbiAgICByZXR1cm4gdmVyc2lvbiA+PSA0ID8gb2soYE5vZGUgdmVyc2lvbiBpcyAke3ZlcnNpb25TdHJpbmd9YCkgOlxuICAgICAgbm9rKCdOb2RlIHZlcnNpb24gc2hvdWxkIGJlIGF0IGxlYXN0IDQhJyk7XG4gIH1cblxuICBmaXggKCkge1xuICAgIHJldHVybiBgTWFudWFsbHkgdXBncmFkZSBOb2RlLmpzLmA7XG4gIH1cbn1cbmNoZWNrcy5wdXNoKG5ldyBOb2RlVmVyc2lvbkNoZWNrKCkpO1xuXG4vLyBQeXRob24gdmVyc2lvbiBjaGVjayB3aGljaCBpcyByZXF1aXJlZCBieSBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzL25vZGUtZ3lwXG5jbGFzcyBPcHRpb25hbFB5dGhvblZlcnNpb25DaGVjayBleHRlbmRzIERvY3RvckNoZWNrIHtcbiAgYXN5bmMgZGlhZ25vc2UgKCkge1xuICAgIGNvbnN0IHB5dGhvblBhdGggPSBhd2FpdCByZXNvbHZlRXhlY3V0YWJsZVBhdGgoYHB5dGhvbiR7c3lzdGVtLmlzV2luZG93cygpID8gYC5FWEVgIDogJyd9YCk7XG4gICAgaWYgKCFweXRob25QYXRoKSB7XG4gICAgICByZXR1cm4gbm9rT3B0aW9uYWwoYFB5dGhvbiByZXF1aXJlZCBieSBub2RlLWd5cCAodXNlZCBieSBoZWFwZHVtcCkgbm90IGZvdW5kIGluIFBBVEg6ICR7cHJvY2Vzcy5lbnYuUEFUSH1gKTtcbiAgICB9XG5cbiAgICAvLyBJdCBjYW4gcmV0dXJuIHZlcnNpb24gbnVtYmVyIGFzIHN0ZGVyclxuICAgIGNvbnN0IHtzdGRvdXQsIHN0ZGVycn0gPSBhd2FpdCBleGVjKHB5dGhvblBhdGgsIFsnLVYnXSk7XG4gICAgbGV0IHZlcnNpb25TdHJpbmcgPSBgJHtzdGRvdXR9ICR7c3RkZXJyfWAubWF0Y2goL1B5dGhvbiAoXFxkKFxcLlxcZCspKikvZyk7XG4gICAgaWYgKHZlcnNpb25TdHJpbmcpIHtcbiAgICAgIHZlcnNpb25TdHJpbmcgPSB2ZXJzaW9uU3RyaW5nLnBvcCgpLnJlcGxhY2UoJ1B5dGhvbiAnLCAnJyk7XG4gICAgfVxuICAgIGNvbnN0IHZlcnNpb24gPSBwYXJzZUludCh2ZXJzaW9uU3RyaW5nLCAxMCk7XG4gICAgaWYgKE51bWJlci5pc05hTih2ZXJzaW9uKSkge1xuICAgICAgcmV0dXJuIG5va09wdGlvbmFsKGBVbmFibGUgdG8gaWRlbnRpZnkgUHl0aG9uIHZlcnNpb24gY29ycmVjdGx5ICh2ZXJzaW9uID0gJyR7dmVyc2lvblN0cmluZ30nKSBhdCAke3B5dGhvblBhdGh9LiBQbGVhc2UgbWFrZSBzdXJlIHlvdXIgUHl0aG9uIGVudmlyb25tZW50IGluIFBBVEg6ICR7cHJvY2Vzcy5lbnYuUEFUSH0uIG5vZGUtZ3lwICh1c2VkIGJ5IGhlYXBkdW1wKSByZXF1aXJlcyBQeXRob24gMi54YCk7XG4gICAgfVxuICAgIHJldHVybiB2ZXJzaW9uID09PSAyID8gb2tPcHRpb25hbChgUHl0aG9uIHJlcXVpcmVkIGJ5IG5vZGUtZ3lwICh1c2VkIGJ5IGhlYXBkdW1wKSBpcyBpbnN0YWxsZWQgYXQ6ICR7cHl0aG9uUGF0aH0uIEluc3RhbGxlZCB2ZXJzaW9uIGlzOiAke3ZlcnNpb25TdHJpbmd9YCkgOlxuICAgICAgbm9rT3B0aW9uYWwoJ1B5dGhvbiB2ZXJzaW9uIHJlcXVpcmVkIGJ5IG5vZGUtZ3lwICh1c2VkIGJ5IGhlYXBkdW1wKSBzaG91bGQgYmUgMi54Jyk7XG4gIH1cblxuICBmaXggKCkge1xuICAgIHJldHVybiBgTWFudWFsbHkgY29uZmlndXJlIFB5dGhvbiAyLnggZW52aXJvbm1lbnQuIG5vZGUtZ3lwIHdoaWNoIGlzIE5vZGVKUyB0b29sY2hhaW4gcmVxdWlyZXMgUHl0aG9uIDIueGA7XG4gIH1cbn1cbmNoZWNrcy5wdXNoKG5ldyBPcHRpb25hbFB5dGhvblZlcnNpb25DaGVjaygpKTtcblxuXG5jbGFzcyBPcHRpb25hbE9wZW5jdjRub2RlanNDb21tYW5kQ2hlY2sgZXh0ZW5kcyBEb2N0b3JDaGVjayB7XG4gIGFzeW5jIGRpYWdub3NlICgpIHtcbiAgICBjb25zdCBwYWNrYWdlTmFtZSA9ICdvcGVuY3Y0bm9kZWpzJztcbiAgICBjb25zdCBwYWNrYWdlSW5mbyA9IGF3YWl0IGdldE5wbVBhY2thZ2VJbmZvKHBhY2thZ2VOYW1lKTtcblxuICAgIGlmIChwYWNrYWdlSW5mbykge1xuICAgICAgcmV0dXJuIG9rT3B0aW9uYWwoYCR7cGFja2FnZU5hbWV9IGlzIGluc3RhbGxlZCBhdDogJHtwYWNrYWdlSW5mby5wYXRofS4gSW5zdGFsbGVkIHZlcnNpb24gaXM6ICR7cGFja2FnZUluZm8udmVyc2lvbn1gKTtcbiAgICB9XG4gICAgcmV0dXJuIG5va09wdGlvbmFsKGAke3BhY2thZ2VOYW1lfSBjYW5ub3QgYmUgZm91bmQuYCk7XG4gIH1cblxuICBhc3luYyBmaXggKCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIHJlcXVpcmUtYXdhaXRcbiAgICByZXR1cm4gJ1doeSBvcGVuY3Y0bm9kZWpzIGlzIG5lZWRlZCBhbmQgaG93IHRvIGluc3RhbGwgaXQ6IGh0dHBzOi8vZ2l0aHViLmNvbS9hcHBpdW0vYXBwaXVtL2Jsb2IvbWFzdGVyL2RvY3MvZW4vd3JpdGluZy1ydW5uaW5nLWFwcGl1bS9pbWFnZS1jb21wYXJpc29uLm1kJztcbiAgfVxufVxuY2hlY2tzLnB1c2gobmV3IE9wdGlvbmFsT3BlbmN2NG5vZGVqc0NvbW1hbmRDaGVjaygpKTtcblxuY2xhc3MgT3B0aW9uYWxGZm1wZWdDb21tYW5kQ2hlY2sgZXh0ZW5kcyBEb2N0b3JDaGVjayB7XG4gIGFzeW5jIGRpYWdub3NlICgpIHtcbiAgICBjb25zdCBmZm1wZWdQYXRoID0gYXdhaXQgcmVzb2x2ZUV4ZWN1dGFibGVQYXRoKCdmZm1wZWcnKTtcbiAgICByZXR1cm4gZmZtcGVnUGF0aFxuICAgICAgPyBva09wdGlvbmFsKGBmZm1wZWcgaXMgaW5zdGFsbGVkIGF0OiAke2ZmbXBlZ1BhdGh9LiAkeyhhd2FpdCBleGVjKCdmZm1wZWcnLCBbJy12ZXJzaW9uJ10pKS5zdGRvdXQuc3BsaXQoRU9MKVswXX1gKVxuICAgICAgOiBub2tPcHRpb25hbCgnZmZtcGVnIGNhbm5vdCBiZSBmb3VuZCcpO1xuICB9XG5cbiAgYXN5bmMgZml4ICgpIHsgLy8gZXNsaW50LWRpc2FibGUtbGluZSByZXF1aXJlLWF3YWl0XG4gICAgcmV0dXJuICdmZm1wZWcgaXMgbmVlZGVkIHRvIHJlY29yZCBzY3JlZW4gZmVhdHVyZXMuIFBsZWFzZSByZWFkIGh0dHBzOi8vd3d3LmZmbXBlZy5vcmcvIHRvIGluc3RhbGwgaXQnO1xuICB9XG59XG5jaGVja3MucHVzaChuZXcgT3B0aW9uYWxGZm1wZWdDb21tYW5kQ2hlY2soKSk7XG5cblxuY2xhc3MgT3B0aW9uYWxNanBlZ0NvbnN1bWVyQ29tbWFuZENoZWNrIGV4dGVuZHMgRG9jdG9yQ2hlY2sge1xuICBhc3luYyBkaWFnbm9zZSAoKSB7XG4gICAgY29uc3QgcGFja2FnZU5hbWUgPSAnbWpwZWctY29uc3VtZXInO1xuICAgIGNvbnN0IHBhY2thZ2VJbmZvID0gYXdhaXQgZ2V0TnBtUGFja2FnZUluZm8ocGFja2FnZU5hbWUpO1xuXG4gICAgaWYgKHBhY2thZ2VJbmZvKSB7XG4gICAgICByZXR1cm4gb2tPcHRpb25hbChgJHtwYWNrYWdlTmFtZX0gaXMgaW5zdGFsbGVkIGF0OiAke3BhY2thZ2VJbmZvLnBhdGh9LiBJbnN0YWxsZWQgdmVyc2lvbiBpczogJHtwYWNrYWdlSW5mby52ZXJzaW9ufWApO1xuICAgIH1cbiAgICByZXR1cm4gbm9rT3B0aW9uYWwoYCR7cGFja2FnZU5hbWV9IGNhbm5vdCBiZSBmb3VuZC5gKTtcbiAgfVxuXG4gIGFzeW5jIGZpeCAoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgcmVxdWlyZS1hd2FpdFxuICAgIHJldHVybiAnbWpwZWctY29uc3VtZXIgbW9kdWxlIGlzIHJlcXVpcmVkIHRvIHVzZSBNSlBFRy1vdmVyLUhUVFAgZmVhdHVyZXMuIFBsZWFzZSBpbnN0YWxsIGl0IHdpdGggYG5wbSBpIC1nIG1qcGVnLWNvbnN1bWVyYC4nO1xuICB9XG59XG5jaGVja3MucHVzaChuZXcgT3B0aW9uYWxNanBlZ0NvbnN1bWVyQ29tbWFuZENoZWNrKCkpO1xuXG5cbmV4cG9ydCB7IE5vZGVCaW5hcnlDaGVjaywgTm9kZVZlcnNpb25DaGVjaywgT3B0aW9uYWxQeXRob25WZXJzaW9uQ2hlY2ssXG4gIE9wdGlvbmFsT3BlbmN2NG5vZGVqc0NvbW1hbmRDaGVjaywgT3B0aW9uYWxGZm1wZWdDb21tYW5kQ2hlY2ssIE9wdGlvbmFsTWpwZWdDb25zdW1lckNvbW1hbmRDaGVjayB9O1xuZXhwb3J0IGRlZmF1bHQgY2hlY2tzO1xuIl0sImZpbGUiOiJsaWIvZ2VuZXJhbC5qcyIsInNvdXJjZVJvb3QiOiIuLi8uLiJ9
